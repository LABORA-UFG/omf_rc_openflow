#!/usr/bin/env ruby

require 'omf_common'
$stdout.sync = true

include OmfCommon

options = {
  user: 'user',
  password: 'pw',
  server: 'srv.mytestbed.net', # XMPP pubsub server domain
  uid: 'flowvisor',
  debug: false
}

flowvisor_id = options[:uid]

Logging.logger.root.level = options[:debug] ? :debug : :info
Blather.logger = logger

# We will use Comm directly, with default DSL implementaion :xmpp
comm = Comm.new(:xmpp)

flowvisor_topic = comm.get_topic(flowvisor_id)

#flowvisor_topic.on_message proc { |m| m.operation != :inform } do |message|
#  logger.warn message
#end

# messages { key: Topic }
msgs = {
  create: comm.create_message([type: 'openflow_slice', name: 'test1']),
  config_a: comm.configure_message([flows: {operation: 'add', device: '00:00:00:00:00:00:00:01', in_port: '16'}]),
#  config_b: comm.configure_message([flows: {operation: 'add', device: '00:00:00:00:00:00:00:02', in_port: '21'}]),
#  config_c: comm.configure_message([flows: {operation: 'add', device: '00:00:00:00:00:00:00:02', in_port: '23'}]),
#  config_d: comm.configure_message([flows: {operation: 'add', device: '00:00:00:00:00:00:00:01', in_port: '15'}]),
#  config_e: comm.configure_message([flows: {operation: 'add', device: '00:00:00:00:00:00:00:01', in_port: '1', eth_src: '00:03:2d:0d:30:d4'}]),
#  config_f: comm.configure_message([flows: {operation: 'add', device: '00:00:00:00:00:00:00:02', in_port: '1', eth_src: '00:03:2d:0d:30:c0'}]),
}

msgs[:create].on_inform_failed do |message|
  logger.error "Resource creation failed ---"
  logger.error message.read_content("reason")
end

%w{config_a}.each do |s|
#config_b config_c config_d config_e config_f}.each do |s|
  msgs[s.to_sym].on_inform_status do |message|
    message.each_property do |p|
      logger.info "#{p.attr('key')} => #{p.content.strip}"
    end
  end
end

msgs[:create].on_inform_created do |message|
  slice_topic = comm.get_topic(message.resource_id)
  slice_id = slice_topic.id

  msgs[:release] ||= comm.release_message { |m| m.element('resource_id', slice_id) }

  msgs[:release].on_inform_released do |message|
    logger.info "Slice (#{message.resource_id}) deleted (resource released)"
  end

  logger.info "Slice #{slice_id} ready for testing"

  slice_topic.subscribe do
    msgs[:config_a].publish slice_id
#    msgs[:config_b].publish slice_id
#    msgs[:config_c].publish slice_id
#    msgs[:config_d].publish slice_id
#    msgs[:config_e].publish slice_id
#    msgs[:config_f].publish slice_id
  end
end

# Then we can register event handlers to the communicator
#
# Event triggered when connection is ready
comm.when_ready do
  logger.info "CONNECTED: #{comm.jid.inspect}"

  # We assume that a openflow_slice_factory (flowvisor) resource proxy instance is up already, so we subscribe to its pubsub topic
  flowvisor_topic.subscribe do
    # If subscribed, we publish a 'create' message, 'create' a new openflow slice for testing
    msgs[:create].publish flowvisor_id
  end
end

EM.run do
  comm.connect(options[:user], options[:password], options[:server])

  trap(:INT) do 
    msgs[:release].publish flowvisor_id
    comm.disconnect
  end
  trap(:TERM) do 
    msgs[:release].publish flowvisor_id
    comm.disconnect
  end
end
